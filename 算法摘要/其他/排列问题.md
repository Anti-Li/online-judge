
### 排列问题


#### 打印某个数组/字符串的所有排列

如果用递归方法构造，每一层相当于选择一个数进行排列，一种普通的思路是定义一个访问数组 `used`， 每次从没有使用过的数中选择一个，标记为 `used`。 Backtracking 的方式。

这样查找可用数，都需要 $N$ 次访问。 虽然分支数不是 $N^N$个（总共的分支数为 $N(N-1)(N-2)\dots 1 = N!$ 个），但是在查找中也是比较浪费时间。

还有一种思路是为了减少查询时间，使用字典之类的东西。但是也并不理想。

 参考 <https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/>

![Backtracking for permutation](https://www.geeksforgeeks.org/wp-content/uploads/NewPermutation.gif)

 这一个思想比较巧妙：

1. 考虑只有2个字符的字符串，交换一下字符位置，就能构成全部排列。
2. 考虑只有3个字符的字符串，固定第一个字符（将3个字符分别与第1个字符交换），对剩下两个字符： 1-1 交换； 1-2 交换，能够成全部排列。
3. 考虑 $n$个字符的字符串， 固定第一个字符（1-1，1-2，...，1-n）交换，再对剩下的递归做排列。

注意递归中要做回溯。

```cpp
// C program to print all permutations with duplicates allowed
#include <stdio.h>
#include <string.h>

/* Function to swap values at two pointers */
void swap(char *x, char *y)
{
    char temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

/* Function to print permutations of string
   This function takes three parameters:
   1. String
   2. Starting index of the string
   3. Ending index of the string. */
void permute(char *a, int l, int r)
{
   int i;
   if (l == r)
     printf("%s\n", a);
   else
   {
       for (i = l; i <= r; i++)
       {
          swap((a+l), (a+i));
          permute(a, l+1, r);
          swap((a+l), (a+i)); //backtrack
       }
   }
}

/* Driver program to test above functions */
int main()
{
    char str[] = "ABC";
    int n = strlen(str);
    permute(str, 0, n-1);
    return 0;
}
```
